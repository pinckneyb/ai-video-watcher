warning: in the working copy of 'surgical_vop_app.py', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/surgical_vop_app.py b/surgical_vop_app.py[m
[1mindex fddd2b7..187a2f6 100644[m
[1m--- a/surgical_vop_app.py[m
[1m+++ b/surgical_vop_app.py[m
[36m@@ -529,6 +529,12 @@[m [mdef initialize_session_state():[m
         st.session_state.assessment_results = None[m
     if 'saved_api_key' not in st.session_state:[m
         st.session_state.saved_api_key = load_api_key()[m
[32m+[m[32m    if 'analysis_mode' not in st.session_state:[m
[32m+[m[32m        st.session_state.analysis_mode = "single"  # "single" or "folder"[m
[32m+[m[32m    if 'folder_results' not in st.session_state:[m
[32m+[m[32m        st.session_state.folder_results = [][m
[32m+[m[32m    if 'folder_processing_complete' not in st.session_state:[m
[32m+[m[32m        st.session_state.folder_processing_complete = False[m
 [m
 def detect_pattern_from_upload(uploaded_file) -> Optional[str]:[m
     """Detect pattern from uploaded file name."""[m
[36m@@ -540,6 +546,212 @@[m [mdef detect_pattern_from_upload(uploaded_file) -> Optional[str]:[m
     # For uploaded files, we don't have folder context[m
     return detector.detect_pattern("", filename)[m
 [m
[32m+[m[32mdef get_supported_videos_from_folder(folder_path: str) -> List[str]:[m
[32m+[m[32m    """Get list of supported video files from folder."""[m
[32m+[m[32m    supported_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.m4v'][m
[32m+[m[32m    video_files = [][m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        for file in os.listdir(folder_path):[m
[32m+[m[32m            if any(file.lower().endswith(ext) for ext in supported_extensions):[m
[32m+[m[32m                video_files.append(os.path.join(folder_path, file))[m
[32m+[m[41m        [m
[32m+[m[32m        # Sort files for consistent processing order[m
[32m+[m[32m        video_files.sort()[m
[32m+[m[32m        return video_files[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        st.error(f"Error reading folder: {e}")[m
[32m+[m[32m        return [][m
[32m+[m
[32m+[m[32mdef process_video_folder(folder_path: str, pattern_id: str, api_key: str, fps: float, batch_size: int, max_concurrent_batches: int):[m
[32m+[m[32m    """Process all videos in folder, generating individual PDFs."""[m
[32m+[m[41m    [m
[32m+[m[32m    # Get list of video files[m
[32m+[m[32m    video_files = get_supported_videos_from_folder(folder_path)[m
[32m+[m[41m    [m
[32m+[m[32m    if not video_files:[m
[32m+[m[32m        st.error("No supported video files found in folder")[m
[32m+[m[32m        return[m
[32m+[m[41m    [m
[32m+[m[32m    st.info(f"Found {len(video_files)} video files to process")[m
[32m+[m[41m    [m
[32m+[m[32m    # Initialize folder results[m
[32m+[m[32m    st.session_state.folder_results = [][m
[32m+[m[32m    st.session_state.folder_processing_complete = False[m
[32m+[m[41m    [m
[32m+[m[32m    # Process each video[m
[32m+[m[32m    for i, video_path in enumerate(video_files, 1):[m
[32m+[m[32m        filename = os.path.basename(video_path)[m
[32m+[m[32m        st.subheader(f"Processing Video {i} of {len(video_files)}: {filename}")[m
[32m+[m[41m        [m
[32m+[m[32m        try:[m
[32m+[m[32m            # Process single video using existing function[m
[32m+[m[32m            result = process_single_video_for_folder([m
[32m+[m[32m                video_path, pattern_id, api_key, fps, batch_size, max_concurrent_batches[m
[32m+[m[32m            )[m
[32m+[m[41m            [m
[32m+[m[32m            if result:[m
[32m+[m[32m                st.session_state.folder_results.append(result)[m
[32m+[m[32m                st.success(f"✅ Completed: {filename}")[m
[32m+[m[32m            else:[m
[32m+[m[32m                st.error(f"❌ Failed: {filename}")[m
[32m+[m[41m                [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            st.error(f"❌ Error processing {filename}: {e}")[m
[32m+[m[32m            continue[m
[32m+[m[41m    [m
[32m+[m[32m    st.session_state.folder_processing_complete = True[m
[32m+[m[32m    st.success(f"🎉 Folder processing complete! Processed {len(st.session_state.folder_results)} videos successfully.")[m
[32m+[m
[32m+[m[32mdef process_single_video_for_folder(video_path: str, pattern_id: str, api_key: str, fps: float, batch_size: int, max_concurrent_batches: int) -> Optional[Dict[str, Any]]:[m
[32m+[m[32m    """Process a single video and return results for folder processing."""[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        # Initialize components[m
[32m+[m[32m        video_processor = VideoProcessor()[m
[32m+[m[32m        gpt4o_client = GPT4oClient(api_key=api_key)[m
[32m+[m[32m        rubric_engine = RubricEngine()[m
[32m+[m[41m        [m
[32m+[m[32m        # Load video[m
[32m+[m[32m        success = video_processor.load_video(video_path, fps)[m
[32m+[m[32m        if not success:[m
[32m+[m[32m            st.error(f"Failed to load video: {video_path}")[m
[32m+[m[32m            return None[m
[32m+[m[41m        [m
[32m+[m[32m        # Extract frames[m
[32m+[m[32m        frames = video_processor.extract_frames(custom_fps=fps)[m
[32m+[m[32m        if not frames:[m
[32m+[m[32m            st.error(f"No frames extracted from video: {video_path}")[m
[32m+[m[32m            return None[m
[32m+[m[41m        [m
[32m+[m[32m        # Create surgical assessment profile[m
[32m+[m[32m        assessment_profile = SurgicalAssessmentProfile(rubric_engine)[m
[32m+[m[32m        surgical_profile = {[m
[32m+[m[32m            "name": "Surgical VOP",[m
[32m+[m[32m            "description": "Surgical Verification of Proficiency Assessment",[m
[32m+[m[32m            "base_prompt": assessment_profile.create_assessment_prompt(pattern_id),[m
[32m+[m[32m            "context_condensation_prompt": assessment_profile.create_context_condensation_prompt()[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        # Create batches[m
[32m+[m[32m        batch_processor = FrameBatchProcessor(batch_size=batch_size)[m
[32m+[m[32m        batches = batch_processor.create_batches(frames)[m
[32m+[m[32m        total_batches = len(batches)[m
[32m+[m[41m        [m
[32m+[m[32m        # Process batches[m
[32m+[m[32m        if max_concurrent_batches > 1:[m
[32m+[m[32m            from app import process_batches_concurrently[m
[32m+[m[32m            performance_metrics = process_batches_concurrently([m
[32m+[m[32m                batches, gpt4o_client, surgical_profile, st.progress(0), st.empty(), total_batches, max_concurrent_batches[m
[32m+[m[32m            )[m
[32m+[m[32m        else:[m
[32m+[m[32m            from app import process_batches_sequentially[m
[32m+[m[32m            process_batches_sequentially(batches, gpt4o_client, surgical_profile, st.progress(0), st.empty(), total_batches)[m
[32m+[m[32m            performance_metrics = None[m
[32m+[m[41m        [m
[32m+[m[32m        # Get analysis results[m
[32m+[m[32m        full_transcript = gpt4o_client.get_full_transcript()[m
[32m+[m[32m        event_timeline = gpt4o_client.get_event_timeline()[m
[32m+[m[41m        [m
[32m+[m[32m        if not full_transcript or len(full_transcript.strip()) < 100:[m
[32m+[m[32m            st.error(f"Insufficient analysis for {video_path}")[m
[32m+[m[32m            return None[m
[32m+[m[41m        [m
[32m+[m[32m        # Generate enhanced narrative[m
[32m+[m[32m        enhanced_narrative = create_surgical_vop_narrative([m
[32m+[m[32m            full_transcript,[m[41m [m
[32m+[m[32m            event_timeline,[m[41m [m
[32m+[m[32m            api_key,[m
[32m+[m[32m            pattern_id,[m
[32m+[m[32m            rubric_engine[m
[32m+[m[32m        )[m
[32m+[m